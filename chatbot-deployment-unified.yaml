apiVersion: v1
kind: ConfigMap
metadata:
  name: chatbot-app-files-enhanced
  namespace: zgrid
data:
  app.py: |
    """
    Z-Grid Chatbot Service with Frontend UI
    A complete chatbot that demonstrates Z-Grid content moderation services with built-in UI
    """
    from fastapi import FastAPI, HTTPException, Request
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.staticfiles import StaticFiles
    from fastapi.responses import HTMLResponse, JSONResponse
    from pydantic import BaseModel
    from typing import Dict, List, Optional, Any
    import requests
    import json
    import os
    import time
    import logging
    from pathlib import Path

    # Set up logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    app = FastAPI(
        title="Z-Grid Chatbot Service with UI",
        description="Chatbot demonstrating Z-Grid content moderation with built-in interface",
        version="3.0.0"
    )

    # CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Configuration - Support both Gateway 1 and Gateway 2
    GATEWAY_URL_V2 = os.getenv("GATEWAY_URL_V2", "http://134.33.132.66:8008")
    GATEWAY_URL = os.getenv("GATEWAY_URL", GATEWAY_URL_V2)
    API_KEY = os.getenv("ZGRID_API_KEY", "supersecret123")
    GATEWAY_TIMEOUT = int(os.getenv("GATEWAY_TIMEOUT", "60"))

    class ChatRequest(BaseModel):
        message: str
        user_name: Optional[str] = "anonymous"

    class ServiceStatus(BaseModel):
        service: str
        status: str  # "pass", "flagged", "blocked", "error"
        triggered: bool
        description: str
        details: Optional[Dict[str, Any]] = None

    class ChatResponse(BaseModel):
        response: str
        moderation_status: str
        service_details: List[ServiceStatus]
        processing_time_ms: Optional[float] = None
        gateway_version: Optional[str] = None

    def create_service_details(response_data: dict) -> List[ServiceStatus]:
        service_descriptions = {
            "pii": "PII Detection - Detects personally identifiable information",
            "policy": "Policy Service - Blocks harmful policy violations",
            "bias": "Bias Detection - Detects biased or stereotypical content",
            "toxicity": "Toxicity Detection - Identifies toxic language patterns",
            "jailbreak": "Jailbreak Detection - Prevents prompt injection attacks",
            "secrets": "Secrets Detection - Identifies exposed sensitive data",
            "ban": "Ban Service - Blocks adult/banned content",
            "format": "Format Checker - Validates response formatting",
            "gibberish": "Gibberish Detection - Identifies nonsense text"
        }

        service_info = []

        # Handle Gateway 2 nested format
        if "data" in response_data:
            actual_data = response_data["data"]
            services_data = actual_data.get("services", {})
        else:
            services_data = response_data.get("services", {})

        for service_name, service_result in services_data.items():
            # Handle nested format in Gateway 2
            if service_result.get("status") == "success" and "data" in service_result:
                # Gateway 2 format - use data.status
                actual_data = service_result["data"]
                status = actual_data.get("status", "pass")
                details = actual_data.get("details", {})
            else:
                # Gateway 1 format - use status directly
                status = service_result.get("status", "pass")
                details = service_result.get("details", {})

            # Map gateway statuses to frontend statuses
            if status == "fail":
                frontend_status = "blocked"
                triggered = True
                description = f"{service_descriptions[service_name]} - Content blocked"
            elif status in ["flagged", "refrain", "allowed_with_warning", "screened", "monitored"]:
                frontend_status = "flagged"
                triggered = True
                if status == "refrain":
                    description = f"{service_descriptions[service_name]} - Content advised against"
                elif status == "allowed_with_warning":
                    description = f"{service_descriptions[service_name]} - Allowed with warnings"
                elif status == "screened":
                    description = f"{service_descriptions[service_name]} - Content screened"
                elif status == "monitored":
                    description = f"{service_descriptions[service_name]} - Content monitored"
                else:
                    description = f"{service_descriptions[service_name]} - Content flagged"
            elif status in ["pass", "allowed", "accepted", "review_required"]:
                frontend_status = "pass"
                triggered = False
                if status == "allowed":
                    description = f"{service_descriptions[service_name]} - Content allowed"
                elif status == "accepted":
                    description = f"{service_descriptions[service_name]} - Content accepted"
                elif status == "review_required":
                    description = f"{service_descriptions[service_name]} - Review required"
                else:
                    description = f"{service_descriptions[service_name]} - Content passed"
            else:
                frontend_status = "error"
                triggered = True
                description = f"{service_descriptions[service_name]} - Error occurred: {status}"

            # Special handling for PII service details
            if service_name == "pii" and "entities" in details:
                pii_entities = details["entities"]
                entity_types = {}
                for entity in pii_entities:
                    entity_type = entity.get("type", "unknown")
                    if entity_type not in entity_types:
                        entity_types[entity_type] = 0
                    entity_types[entity_type] += 1

                # Create PII summary for frontend
                details["pii_summary"] = {
                    "total_count": len(pii_entities),
                    "entity_types": entity_types,
                    "top_entities": pii_entities[:10],
                    "entity_summary": [f"{entity_type}: {count}" for entity_type, count in entity_types.items()]
                }

            service_info.append(ServiceStatus(
                service=service_name.replace("_", " ").title(),
                status=frontend_status,
                triggered=triggered,
                description=description,
                details=details
            ))

        return service_info

    @app.get("/", response_class=HTMLResponse)
    async def serve_frontend():
        """Serve the frontend HTML interface"""
        return HTMLResponse(content=FRONTEND_HTML)

    @app.get("/api")
    async def api_info():
        """API info endpoint"""
        return {
            "message": "Z-Grid Chatbot API",
            "version": "3.0.0",
            "endpoints": {
                "chat": "POST /api/chat",
                "health": "GET /api/health"
            }
        }

    @app.get("/api/health")
    async def health_check():
        return {"status": "healthy", "service": "Z-Grid Chatbot with UI", "version": "3.0.0"}

    @app.post("/api/chat", response_model=ChatResponse)
    async def chat(request: ChatRequest):
        start_time = time.time()

        try:
            # Prepare request for gateway
            gateway_payload = {
                "text": request.message,
                "user_id": request.user_name
            }

            headers = {
                "Content-Type": "application/json",
                "X-API-Key": API_KEY
            }

            # Call Gateway 2
            response = requests.post(
                f"{GATEWAY_URL}/validate",
                json=gateway_payload,
                headers=headers,
                timeout=GATEWAY_TIMEOUT
            )

            response.raise_for_status()
            gateway_response = response.json()

            processing_time_ms = (time.time() - start_time) * 1000

            # Determine overall moderation status
            if "data" in gateway_response:
                actual_data = gateway_response["data"]
                services_data = actual_data.get("services", {})
                overall_status = actual_data.get("overall_status", "pass")
            else:
                services_data = gateway_response.get("services", {})
                overall_status = gateway_response.get("overall_status", "pass")

            # Determine moderation status based on service results
            moderation_status = "pass"
            for service_name, service_result in services_data.items():
                if "data" in service_result and service_result.get("status") == "success":
                    service_status = service_result["data"].get("status", "pass")
                else:
                    service_status = service_result.get("status", "pass")

                if service_status == "fail":
                    moderation_status = "blocked"
                    break
                elif service_status in ["flagged", "refrain", "allowed_with_warning"]:
                    if moderation_status != "blocked":
                        moderation_status = "flagged"

            # Create service details
            service_details = create_service_details(gateway_response)

            # Generate response based on moderation status
            if moderation_status == "blocked":
                response_text = "I apologize, but I cannot process this request as it violates content policies."
            elif moderation_status == "flagged":
                response_text = f"I understand your message: '{request.message}'. However, I notice this content may be sensitive. Please proceed with caution."
            else:
                response_text = f"Hello {request.user_name}! I received your message: '{request.message}'. How can I help you today?"

            return ChatResponse(
                response=response_text,
                moderation_status=moderation_status,
                service_details=service_details,
                processing_time_ms=processing_time_ms,
                gateway_version="Gateway 2"
            )

        except requests.exceptions.Timeout:
            logger.error(f"Gateway timeout after {GATEWAY_TIMEOUT} seconds")
            processing_time_ms = (time.time() - start_time) * 1000
            return ChatResponse(
                response="I apologize, but the service is experiencing high demand. Please try again later.",
                moderation_status="error",
                service_details=[],
                processing_time_ms=processing_time_ms,
                gateway_version="Gateway 2 (Timeout)"
            )

        except requests.exceptions.RequestException as e:
            logger.error(f"Gateway connection error: {e}")
            processing_time_ms = (time.time() - start_time) * 1000
            return ChatResponse(
                response="I apologize, but I am currently experiencing technical difficulties. Please try again later.",
                moderation_status="error",
                service_details=[],
                processing_time_ms=processing_time_ms,
                gateway_version="Gateway 2 (Error)"
            )

        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            processing_time_ms = (time.time() - start_time) * 1000
            return ChatResponse(
                response="I apologize, but an unexpected error occurred. Please try again later.",
                moderation_status="error",
                service_details=[],
                processing_time_ms=processing_time_ms,
                gateway_version="Gateway 2 (Error)"
            )

    # Frontend HTML content
    FRONTEND_HTML = """<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Z-Grid Chatbot</title>
      <style>
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
          margin: 0;
          padding: 20px;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          min-height: 100vh;
        }
        .container {
          max-width: 800px;
          margin: 0 auto;
          background: white;
          border-radius: 12px;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
          overflow: hidden;
        }
        .header {
          background: #4a5568;
          color: white;
          padding: 20px;
          text-align: center;
        }
        .chat-container {
          height: 500px;
          overflow-y: auto;
          padding: 20px;
          background: #f7fafc;
        }
        .message {
          margin-bottom: 15px;
          padding: 12px 16px;
          border-radius: 18px;
          max-width: 70%;
          word-wrap: break-word;
        }
        .user-message {
          background: #3182ce;
          color: white;
          margin-left: auto;
          text-align: right;
        }
        .bot-message {
          background: #e2e8f0;
          color: #2d3748;
        }
        .input-container {
          padding: 20px;
          background: white;
          border-top: 1px solid #e2e8f0;
          display: flex;
          gap: 10px;
        }
        input {
          flex: 1;
          padding: 12px 16px;
          border: 1px solid #cbd5e0;
          border-radius: 25px;
          outline: none;
          font-size: 14px;
        }
        button {
          padding: 12px 24px;
          background: #3182ce;
          color: white;
          border: none;
          border-radius: 25px;
          cursor: pointer;
          font-weight: 500;
        }
        button:hover {
          background: #2c5aa0;
        }
        .status-indicator {
          display: inline-block;
          padding: 4px 8px;
          border-radius: 12px;
          font-size: 12px;
          font-weight: 500;
          margin-left: 8px;
        }
        .status-pass { background: #c6f6d5; color: #22543d; }
        .status-flagged { background: #fed7aa; color: #7c2d12; }
        .status-blocked { background: #fed7d7; color: #742a2a; }
        .status-error { background: #e2e8f0; color: #2d3748; }
        .service-details {
          margin-top: 8px;
          font-size: 11px;
          opacity: 0.8;
        }
        .hover-trigger {
          cursor: pointer;
          text-decoration: underline;
        }
        .tooltip {
          position: relative;
          display: inline-block;
        }
        .tooltip-content {
          display: none;
          position: absolute;
          bottom: 125%;
          left: 50%;
          transform: translateX(-50%);
          background: #2d3748;
          color: white;
          padding: 8px 12px;
          border-radius: 6px;
          white-space: nowrap;
          z-index: 1000;
          max-width: 300px;
          white-space: normal;
        }
        .tooltip:hover .tooltip-content {
          display: block;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>ü§ñ Z-Grid Content Moderation Chatbot</h1>
          <p>Powered by AI Gateway 2 with Real-time Content Analysis</p>
        </div>

        <div id="chatContainer" class="chat-container">
          <div class="message bot-message">
            Welcome to Z-Grid Chatbot! I demonstrate real-time content moderation using Gateway 2. Try sending different types of messages to see how our AI services detect and handle various content categories.
          </div>
        </div>

        <div class="input-container">
          <input type="text" id="messageInput" placeholder="Type your message here..."
                 onkeypress="if(event.key === 'Enter') sendMessage()">
          <button onclick="sendMessage()">Send</button>
        </div>
      </div>

      <script>
        let messageHistory = [];

        function addMessage(content, isUser = false, moderationData = null) {
          const chatContainer = document.getElementById('chatContainer');
          const messageDiv = document.createElement('div');
          messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;

          if (isUser) {
            messageDiv.textContent = content;
          } else {
            messageDiv.innerHTML = content;

            if (moderationData) {
              const statusClass = `status-${moderationData.moderation_status}`;
              const statusText = moderationData.moderation_status.toUpperCase();
              messageDiv.innerHTML += `<span class="status-indicator ${statusClass}">${statusText}</span>`;

              if (moderationData.service_details && moderationData.service_details.length > 0) {
                const servicesHtml = moderationData.service_details
                  .filter(s => s.triggered)
                  .map(s => `<div class="service-details"><strong>${s.service}:</strong> ${s.description}</div>`)
                  .join('');

                if (servicesHtml) {
                  messageDiv.innerHTML += `<div class="tooltip hover-trigger">‚ÑπÔ∏è Service Details<div class="tooltip-content">${servicesHtml}</div></div>`;
                }
              }
            }
          }

          chatContainer.appendChild(messageDiv);
          chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        async function sendMessage() {
          const input = document.getElementById('messageInput');
          const message = input.value.trim();

          if (!message) return;

          addMessage(message, true);
          input.value = '';

          try {
            const response = await fetch('/api/chat', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                message: message,
                user_name: 'user'
              })
            });

            const data = await response.json();
            addMessage(data.response, false, {
              moderation_status: data.moderation_status,
              service_details: data.service_details
            });
          } catch (error) {
            console.error('Error:', error);
            addMessage('Sorry, I encountered an error. Please try again.', false);
          }
        }

        // Add some example messages for testing
        window.addEventListener('load', () => {
          setTimeout(() => {
            addMessage('üí° Try these examples:<br>‚Ä¢ "Hello, how are you?"<br>‚Ä¢ "My email is john@example.com"<br>‚Ä¢ "I hate everyone!"<br>‚Ä¢ "John Doe, SSN 123-45-6789"', false);
          }, 1000);
        });
      </script>
    </body>
    </html>"""

  requirements.txt: |
    fastapi==0.104.1
    uvicorn[standard]==0.24.0
    pydantic==2.4.2
    requests==2.31.0
    python-multipart==0.0.6

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: zgrid-chatbot-service-enhanced
  namespace: zgrid
  labels:
    app: zgrid-chatbot-service-enhanced
    component: chatbot-ui
    version: v3-unified
spec:
  replicas: 1
  selector:
    matchLabels:
      app: zgrid-chatbot-service-enhanced
  template:
    metadata:
      labels:
        app: zgrid-chatbot-service-enhanced
        component: chatbot-ui
        version: v3-unified
    spec:
      containers:
      - name: chatbot-service
        image: python:3.11-slim
        command: ['sh', '-c', '
          echo "Installing dependencies...";
          pip install -r /app/requirements.txt;
          echo "Starting enhanced chatbot service with UI...";
          cd /app;
          python -m uvicorn app:app --host 0.0.0.0 --port 8010;
        ']
        ports:
        - containerPort: 8010
          name: http
          protocol: TCP
        env:
        - name: GATEWAY_URL_V2
          value: "http://134.33.132.66:8008"
        - name: GATEWAY_URL
          value: "http://134.33.132.66:8008"
        - name: ZGRID_API_KEY
          value: "supersecret123"
        - name: LOG_LEVEL
          value: "INFO"
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /
            port: 8010
          initialDelaySeconds: 45
          periodSeconds: 10
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /
            port: 8010
          initialDelaySeconds: 30
          periodSeconds: 5
          timeoutSeconds: 5
          failureThreshold: 3
        volumeMounts:
        - name: app-files
          mountPath: /app
      volumes:
      - name: app-files
        configMap:
          name: chatbot-app-files-enhanced
      restartPolicy: Always
      terminationGracePeriodSeconds: 30

---
apiVersion: v1
kind: Service
metadata:
  name: zgrid-chatbot-service-unified
  namespace: zgrid
  labels:
    app: zgrid-chatbot-service-enhanced
    component: chatbot-ui
  annotations:
    service.beta.kubernetes.io/azure-load-balancer-internal: "false"
spec:
  selector:
    app: zgrid-chatbot-service-enhanced
  ports:
  - name: http
    port: 8010
    targetPort: 8010
    protocol: TCP
  type: LoadBalancer