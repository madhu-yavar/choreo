apiVersion: apps/v1
kind: Deployment
metadata:
  name: secrets-service-working
  namespace: z-grid
  labels:
    app: secrets-service-working
spec:
  replicas: 1
  selector:
    matchLabels:
      app: secrets-service-working
  template:
    metadata:
      labels:
        app: secrets-service-working
    spec:
      containers:
      - name: secrets-service-working
        image: python:3.11-slim
        command:
        - /bin/bash
        - -c
        - |
          pip install flask requests regex
          cat > /app/secrets_service.py << 'EOF'
          from flask import Flask, request, jsonify
          from datetime import datetime
          import re
          import os

          app = Flask(__name__)

          SECRETS_API_KEYS = ['secrets123', 'supersecret123', 'biasyavar', 'enhancedsecrets123']

          # Common secret patterns to detect
          SECRET_PATTERNS = {
              'api_key': r'[Aa][Pp][Ii][_\\-\\s]?[Kk][Ee][Yy][\\s:=]+[\\'\\"]?([a-zA-Z0-9_\\-]{16,})[\\'\\"]?',
              'aws_access_key': r'AKIA[0-9A-Z]{16}',
              'aws_secret': r'[A-Za-z0-9/+=]{40}',
              'password': r'[Pp][Aa][Ss][Ss][Ww][Oo][Rr][Dd][\\s:=]+[\\'\\"]?([^\\'\\\"\\s]{6,})[\\'\\"]?',
              'token': r'[Tt][Oo][Kk][Ee][Nn][\\s:=]+[\\'\\"]?([a-zA-Z0-9._\\-]{15,})[\\'\\"]?',
              'bearer': r'[Bb][Ee][Aa][Rr][Ee][Rr][\\s:=]+[\\'\\"]?([a-zA-Z0-9._\\-]{20,})[\\'\\"]?',
              'private_key': r'-----BEGIN [A-Z ]+-----[\\sA-Za-z0-9+/=]+-----END [A-Z ]+-----',
              'database_url': r'[Dd][Aa][Tt][Aa][Bb][Aa][Ss][Ee][_\\-]?[Uu][Rr][Ll][\\s:=]+[\\'\\"]?([^\\'\\\"\\s]{10,})[\\'\\"]?',
              'jwt': r'eyJ[a-zA-Z0-9._-]*\\.eyJ[a-zA-Z0-9._-]*\\.[a-zA-Z0-9._-]*'
          }

          def validate_api_key():
              api_key = request.headers.get('X-API-Key')
              return api_key in SECRETS_API_KEYS

          def detect_secrets(text):
              findings = []
              for secret_type, pattern in SECRET_PATTERNS.items():
                  matches = re.finditer(pattern, text, re.IGNORECASE | re.MULTILINE)
                  for match in matches:
                      # Mask the detected secret
                      if secret_type == 'jwt':
                          masked = match.group(0)[:10] + '*' * 20 + match.group(0)[-10:]
                      elif len(match.group(0)) > 20:
                          masked = match.group(0)[:8] + '*' * (len(match.group(0)) - 16) + match.group(0)[-8:]
                      else:
                          masked = '*' * len(match.group(0))

                      findings.append({
                          'type': secret_type,
                          'confidence': 0.9,
                          'pattern': pattern,
                          'matched_text': masked,
                          'start_pos': match.start(),
                          'end_pos': match.end()
                      })
              return findings

          @app.route('/health', methods=['GET'])
          def health():
              return jsonify({
                  'ok': True,
                  'service': 'Secrets Detection Service',
                  'status': 'running',
                  'timestamp': datetime.now().isoformat()
              })

          @app.route('/secrets/scan', methods=['POST'])
          def scan_secrets():
              if not validate_api_key():
                  return jsonify({'error': 'Invalid API key'}), 401

              data = request.get_json()
              if not data or 'text' not in data:
                  return jsonify({'error': 'Text is required'}), 400

              text = data['text']
              findings = detect_secrets(text)

              # Calculate risk score
              risk_score = 0.0
              for finding in findings:
                  if finding['type'] in ['api_key', 'aws_access_key', 'aws_secret', 'private_key', 'jwt']:
                      risk_score += 0.3
                  else:
                      risk_score += 0.1
              risk_score = min(risk_score, 1.0)

              return jsonify({
                  'text_length': len(text),
                  'secrets_found': len(findings),
                  'risk_score': round(risk_score, 2),
                  'high_risk': risk_score > 0.7,
                  'findings': findings,
                  'scan_time': datetime.now().isoformat()
              })

          @app.route('/secrets/redact', methods=['POST'])
          def redact_secrets():
              if not validate_api_key():
                  return jsonify({'error': 'Invalid API key'}), 401

              data = request.get_json()
              if not data or 'text' not in data:
                  return jsonify({'error': 'Text is required'}), 400

              text = data['text']
              findings = detect_secrets(text)

              redacted_text = text
              # Sort findings by position in reverse order to avoid index shifting
              findings_sorted = sorted(findings, key=lambda x: x['start_pos'], reverse=True)

              for finding in findings_sorted:
                  original = text[finding['start_pos']:finding['end_pos']]
                  replacement = '[REDACTED_' + finding['type'].upper() + ']'
                  redacted_text = redacted_text[:finding['start_pos']] + replacement + redacted_text[finding['end_pos']:]

              return jsonify({
                  'original_length': len(text),
                  'redacted_length': len(redacted_text),
                  'secrets_redacted': len(findings),
                  'redacted_text': redacted_text,
                  'redaction_time': datetime.now().isoformat()
              })

          if __name__ == '__main__':
              print("ðŸš€ Secrets Service Starting...")
              app.run(host='0.0.0.0', port=8005, debug=False)
          EOF
          python3 /app/secrets_service.py
          from flask import Flask, request, jsonify
          from datetime import datetime
          import re
          import os

          app = Flask(__name__)

          SECRETS_API_KEYS = ['secrets123', 'supersecret123', 'biasyavar', 'enhancedsecrets123']

          # Common secret patterns to detect
          SECRET_PATTERNS = {
              'api_key': r'[Aa][Pp][Ii][_\\-\\s]?[Kk][Ee][Yy][\\s:=]+[\\'\\"]?([a-zA-Z0-9_\\-]{16,})[\\'\\"]?',
              'aws_access_key': r'AKIA[0-9A-Z]{16}',
              'aws_secret': r'[A-Za-z0-9/+=]{40}',
              'password': r'[Pp][Aa][Ss][Ss][Ww][Oo][Rr][Dd][\\s:=]+[\\'\\"]?([^\\'\\\"\\s]{6,})[\\'\\"]?',
              'token': r'[Tt][Oo][Kk][Ee][Nn][\\s:=]+[\\'\\"]?([a-zA-Z0-9._\\-]{15,})[\\'\\"]?',
              'bearer': r'[Bb][Ee][Aa][Rr][Ee][Rr][\\s:=]+[\\'\\"]?([a-zA-Z0-9._\\-]{20,})[\\'\\"]?',
              'private_key': r'-----BEGIN [A-Z ]+-----[\\sA-Za-z0-9+/=]+-----END [A-Z ]+-----',
              'database_url': r'[Dd][Aa][Tt][Aa][Bb][Aa][Ss][Ee][_\\-]?[Uu][Rr][Ll][\\s:=]+[\\'\\"]?([^\\'\\\"\\s]{10,})[\\'\\"]?',
              'jwt': r'eyJ[a-zA-Z0-9._-]*\\.eyJ[a-zA-Z0-9._-]*\\.[a-zA-Z0-9._-]*'
          }

          def validate_api_key():
              api_key = request.headers.get('X-API-Key')
              return api_key in SECRETS_API_KEYS

          def detect_secrets(text):
              findings = []
              for secret_type, pattern in SECRET_PATTERNS.items():
                  matches = re.finditer(pattern, text, re.IGNORECASE | re.MULTILINE)
                  for match in matches:
                      # Mask the detected secret
                      if secret_type == 'jwt':
                          masked = match.group(0)[:10] + '*' * 20 + match.group(0)[-10:]
                      elif len(match.group(0)) > 20:
                          masked = match.group(0)[:8] + '*' * (len(match.group(0)) - 16) + match.group(0)[-8:]
                      else:
                          masked = '*' * len(match.group(0))

                      findings.append({
                          'type': secret_type,
                          'confidence': 0.9,
                          'pattern': pattern,
                          'matched_text': masked,
                          'start_pos': match.start(),
                          'end_pos': match.end()
                      })
              return findings

          @app.route('/health', methods=['GET'])
          def health():
              return jsonify({
                  'ok': True,
                  'service': 'Secrets Detection Service',
                  'status': 'running',
                  'timestamp': datetime.now().isoformat()
              })

          @app.route('/secrets/scan', methods=['POST'])
          def scan_secrets():
              if not validate_api_key():
                  return jsonify({'error': 'Invalid API key'}), 401

              data = request.get_json()
              if not data or 'text' not in data:
                  return jsonify({'error': 'Text is required'}), 400

              text = data['text']
              findings = detect_secrets(text)

              # Calculate risk score
              risk_score = 0.0
              for finding in findings:
                  if finding['type'] in ['api_key', 'aws_access_key', 'aws_secret', 'private_key', 'jwt']:
                      risk_score += 0.3
                  else:
                      risk_score += 0.1
              risk_score = min(risk_score, 1.0)

              return jsonify({
                  'text_length': len(text),
                  'secrets_found': len(findings),
                  'risk_score': round(risk_score, 2),
                  'high_risk': risk_score > 0.7,
                  'findings': findings,
                  'scan_time': datetime.now().isoformat()
              })

          @app.route('/secrets/redact', methods=['POST'])
          def redact_secrets():
              if not validate_api_key():
                  return jsonify({'error': 'Invalid API key'}), 401

              data = request.get_json()
              if not data or 'text' not in data:
                  return jsonify({'error': 'Text is required'}), 400

              text = data['text']
              findings = detect_secrets(text)

              redacted_text = text
              # Sort findings by position in reverse order to avoid index shifting
              findings_sorted = sorted(findings, key=lambda x: x['start_pos'], reverse=True)

              for finding in findings_sorted:
                  original = text[finding['start_pos']:finding['end_pos']]
                  replacement = '[REDACTED_' + finding['type'].upper() + ']'
                  redacted_text = redacted_text[:finding['start_pos']] + replacement + redacted_text[finding['end_pos']:]

              return jsonify({
                  'original_length': len(text),
                  'redacted_length': len(redacted_text),
                  'secrets_redacted': len(findings),
                  'redacted_text': redacted_text,
                  'redaction_time': datetime.now().isoformat()
              })

          if __name__ == '__main__':
              print(\"ðŸš€ Secrets Service Starting...\")
              app.run(host='0.0.0.0', port=8005, debug=False)
          "
        ports:
        - containerPort: 8005
        env:
        - name: SECRETS_API_KEYS
          value: "secrets123,supersecret123,biasyavar,enhancedsecrets123"
        resources:
          requests:
            cpu: "100m"
            memory: "256Mi"
          limits:
            cpu: "500m"
            memory: "512Mi"
        livenessProbe:
          httpGet:
            path: /health
            port: 8005
          initialDelaySeconds: 10
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8005
          initialDelaySeconds: 5
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: secrets-service-working
  namespace: z-grid
spec:
  selector:
    app: secrets-service-working
  ports:
  - port: 8005
    targetPort: 8005
  type: LoadBalancer