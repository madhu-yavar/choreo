apiVersion: apps/v1
kind: Deployment
metadata:
  name: format-service-working
  namespace: z-grid
  labels:
    app: format-service-working
spec:
  replicas: 1
  selector:
    matchLabels:
      app: format-service-working
  template:
    metadata:
      labels:
        app: format-service-working
    spec:
      containers:
      - name: format-service-working
        image: python:3.11-slim
        command:
        - /bin/bash
        - -c
        - |
          pip install flask requests re
          python3 -c "
          from flask import Flask, request, jsonify
          from datetime import datetime
          import re
          import html

          app = Flask(__name__)

          FORMAT_API_KEYS = ['format123', 'supersecret123', 'biasyavar', 'enhancedformat123']

          def validate_api_key():
              api_key = request.headers.get('X-API-Key')
              return api_key in FORMAT_API_KEYS

          def detect_format_issues(text):
              issues = []

              # Check for excessive whitespace
              if re.search(r'\\n\\s*\\n\\s*\\n', text):  # Triple newlines
                  issues.append({
                      'type': 'excessive_whitespace',
                      'severity': 'low',
                      'description': 'Contains excessive line breaks',
                      'count': len(re.findall(r'\\n\\s*\\n\\s*\\n', text))
                  })

              # Check for mixed line endings
              if '\\r\\n' in text and '\\n' in text:
                  issues.append({
                      'type': 'mixed_line_endings',
                      'severity': 'medium',
                      'description': 'Mixed Windows and Unix line endings detected'
                  })

              # Check for trailing whitespace
              if re.search(r'[ \\t]+\\n', text):
                  issues.append({
                      'type': 'trailing_whitespace',
                      'severity': 'low',
                      'description': 'Lines with trailing whitespace',
                      'count': len(re.findall(r'[ \\t]+\\n', text))
                  })

              # Check for inconsistent indentation
              lines = text.split('\\n')
              indentations = []
              for line in lines:
                  if line.strip():  # Skip empty lines
                      match = re.match(r'^([ \\t]*)', line)
                      if match:
                          indentations.append(len(match.group(1)))

              if len(set(indentations)) > 3:  # More than 3 different indentation levels
                  issues.append({
                      'type': 'inconsistent_indentation',
                      'severity': 'medium',
                      'description': 'Inconsistent indentation detected',
                      'unique_levels': len(set(indentations))
                  })

              # Check for encoding issues (non-ASCII characters)
              non_ascii = len([c for c in text if ord(c) > 127])
              if non_ascii > 0:
                  issues.append({
                      'type': 'non_ascii_characters',
                      'severity': 'info',
                      'description': 'Contains non-ASCII characters',
                      'count': non_ascii
                  })

              # Check for HTML escaping issues
              if '<' in text and '>' in text:
                  unescaped_html = re.findall(r'<[^>]+>', text)
                  if unescaped_html:
                      issues.append({
                          'type': 'unescaped_html',
                          'severity': 'medium',
                          'description': 'Potential unescaped HTML content',
                          'count': len(unescaped_html)
                      })

              # Check for potential code injection patterns
              injection_patterns = [
                  r'<script[^>]*>',
                  r'javascript:',
                  r'vbscript:',
                  r'data:text/html',
                  r'eval\\(',
                  r'exec\\('
              ]

              for pattern in injection_patterns:
                  matches = re.findall(pattern, text, re.IGNORECASE)
                  if matches:
                      issues.append({
                          'type': 'potential_injection',
                          'severity': 'high',
                          'description': f'Potential code injection pattern detected: {pattern}',
                          'count': len(matches)
                      })

              return issues

          @app.route('/health', methods=['GET'])
          def health():
              return jsonify({
                  'ok': True,
                  'service': 'Format Validation Service',
                  'status': 'running',
                  'timestamp': datetime.now().isoformat()
              })

          @app.route('/format/validate', methods=['POST'])
          def validate_format():
              if not validate_api_key():
                  return jsonify({'error': 'Invalid API key'}), 401

              data = request.get_json()
              if not data or 'text' not in data:
                  return jsonify({'error': 'Text is required'}), 400

              text = data['text']
              issues = detect_format_issues(text)

              # Calculate overall quality score
              score = 100
              for issue in issues:
                  if issue['severity'] == 'high':
                      score -= 20
                  elif issue['severity'] == 'medium':
                      score -= 10
                  elif issue['severity'] == 'low':
                      score -= 5
                  elif issue['severity'] == 'info':
                      score -= 1

              score = max(0, score)

              return jsonify({
                  'text_length': len(text),
                  'line_count': len(text.split('\\n')),
                  'quality_score': score,
                  'issues_found': len(issues),
                  'issues': issues,
                  'validation_time': datetime.now().isoformat()
              })

          @app.route('/format/sanitize', methods=['POST'])
          def sanitize_format():
              if not validate_api_key():
                  return jsonify({'error': 'Invalid API key'}), 401

              data = request.get_json()
              if not data or 'text' not in data:
                  return jsonify({'error': 'Text is required'}), 400

              text = data['text']
              sanitized_text = text

              # Fix common formatting issues
              changes = []

              # Remove excessive whitespace
              original_count = len(re.findall(r'\\n\\s*\\n\\s*\\n', sanitized_text))
              if original_count > 0:
                  sanitized_text = re.sub(r'\\n\\s*\\n\\s*\\n+', '\\n\\n', sanitized_text)
                  changes.append(f'Removed {original_count} instances of excessive line breaks')

              # Remove trailing whitespace
              original_lines = len(re.findall(r'[ \\t]+\\n', sanitized_text))
              if original_lines > 0:
                  sanitized_text = re.sub(r'[ \\t]+\\n', '\\n', sanitized_text)
                  changes.append(f'Removed trailing whitespace from {original_lines} lines')

              # Normalize line endings
              if '\\r\\n' in sanitized_text:
                  sanitized_text = sanitized_text.replace('\\r\\n', '\\n')
                  changes.append('Normalized Windows line endings to Unix')

              # HTML escape dangerous content
              dangerous_patterns = [r'<script[^>]*>.*?</script>', r'javascript:', r'vbscript:']
              for pattern in dangerous_patterns:
                  if re.search(pattern, sanitized_text, re.IGNORECASE | re.DOTALL):
                      sanitized_text = re.sub(pattern, lambda m: html.escape(m.group(0)), sanitized_text, flags=re.IGNORECASE | re.DOTALL)
                      changes.append(f'HTML escaped dangerous content: {pattern}')

              return jsonify({
                  'original_length': len(text),
                  'sanitized_length': len(sanitized_text),
                  'changes_made': len(changes),
                  'changes': changes,
                  'sanitized_text': sanitized_text,
                  'sanitization_time': datetime.now().isoformat()
              })

          @app.route('/format/info', methods=['GET'])
          def format_info():
              return jsonify({
                  'service': 'Format Validation Service',
                  'version': '1.0.0',
                  'capabilities': [
                      'Format validation and quality scoring',
                      'Whitespace and indentation analysis',
                      'HTML injection detection',
                      'Character encoding validation',
                      'Text sanitization and cleanup'
                  ],
                  'supported_operations': [
                      'POST /format/validate - Validate text format',
                      'POST /format/sanitize - Sanitize and clean text',
                      'GET /health - Service health check'
                  ],
                  'api_keys': ['format123', 'supersecret123', 'biasyavar', 'enhancedformat123']
              })

          if __name__ == '__main__':
              print(\"ðŸš€ Format Service Starting...\")
              app.run(host='0.0.0.0', port=8006, debug=False)
          "
        ports:
        - containerPort: 8006
        env:
        - name: FORMAT_API_KEYS
          value: "format123,supersecret123,biasyavar,enhancedformat123"
        resources:
          requests:
            cpu: "100m"
            memory: "256Mi"
          limits:
            cpu: "500m"
            memory: "512Mi"
        livenessProbe:
          httpGet:
            path: /health
            port: 8006
          initialDelaySeconds: 10
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8006
          initialDelaySeconds: 5
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: format-service-working
  namespace: z-grid
spec:
  selector:
    app: format-service-working
  ports:
  - port: 8006
    targetPort: 8006
  type: LoadBalancer